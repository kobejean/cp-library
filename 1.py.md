---
data:
  _extendedDependsOn: []
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: py
  _verificationStatusIcon: ':warning:'
  attributes:
    PROBLEM: https://judge.yosupo.jp/problem/unionfind_with_potential
    links:
    - https://judge.yosupo.jp/problem/unionfind_with_potential
  bundledCode: "# verification-helper: PROBLEM https://judge.yosupo.jp/problem/unionfind_with_potential\n\
    \nclass PotentializedDSU:\n\n    def __init__(self, op, inv, e, v) -> None:\n\
    \        n = v if isinstance(v, int) else len(v)\n        self.n = n\n       \
    \ self.par = [-1] * n\n        self.op = op\n        self.inv = inv\n        self.e\
    \ = e\n        self.pot = [e] * n if isinstance(v, int) else v\n\n    def leader(self,\
    \ x: int) -> int:\n        assert 0 <= x < self.n\n        path = []\n       \
    \ while self.par[x] >= 0:\n            path.append(x)\n            x = self.par[x]\n\
    \        for y in reversed(path):\n            self.pot[y] = self.op(self.pot[y],\
    \ self.pot[self.par[y]])\n            self.par[y] = x\n        return x\n    \n\
    \    def consistent(self, x: int, y: int, w) -> bool:\n        rx = self.leader(x)\n\
    \        ry = self.leader(y)\n        if rx == ry:\n            return self.op(self.pot[x],\
    \ self.inv(self.pot[y])) == w\n        return True\n\n    def merge(self, x: int,\
    \ y: int, w) -> int:\n        assert 0 <= x < self.n\n        assert 0 <= y <\
    \ self.n\n        rx = self.leader(x)\n        ry = self.leader(y)\n        if\
    \ rx == ry:\n            return rx\n        \n        if self.par[rx] < self.par[ry]:\n\
    \            x,y,w,rx,ry = y,x,self.inv(w),ry,rx\n            \n        self.par[ry]\
    \ += self.par[rx]\n        self.par[rx] = ry\n        self.pot[rx] = self.op(\n\
    \            self.op(self.inv(self.pot[x]), w), self.pot[y]\n        )\n     \
    \   return ry\n\n    def same(self, x: int, y: int) -> bool:\n        assert 0\
    \ <= x < self.n\n        assert 0 <= y < self.n\n        return self.leader(x)\
    \ == self.leader(y)\n    \n    def size(self, x: int) -> int:\n        assert\
    \ 0 <= x < self.n\n        return -self.par[self.leader(x)]\n    \n    def groups(self):\n\
    \        leader_buf = [self.leader(i) for i in range(self.n)]\n\n        result\
    \ = [[] for _ in range(self.n)]\n        for i in range(self.n):\n           \
    \ result[leader_buf[i]].append(i)\n\n        return list(filter(lambda r: r, result))\n\
    \n    def diff(self, x: int, y: int):\n        assert self.same(x, y)\n      \
    \  return self.op(self.pot[x], self.inv(self.pot[y]))\n\nimport math\n# from bisect\
    \ import bisect_left\nfrom bisect import bisect_right\n\ndef matmul(A, B, mod):\n\
    \    N1, N2, N3 = len(A),len(B),len(B[0])\n    R = [[0]*N3 for _ in range(N1)]\n\
    \    for i in range(N1):\n        for j in range(N3):\n            for k in range(N2):\n\
    \                R[i][j] += A[i][k]*B[k][j] % mod\n                R[i][j] %=\
    \ mod\n    return R\n\nfrom bisect import bisect_left\n\ndef matpow(A, K, mod):\n\
    \    N = len(A)\n    R = [[int(i == j) for j in range(N)] for i in range(N)]\n\
    \    An = [[aij for aij in ai] for ai in A]\n    while K > 0:\n        if K &\
    \ 1:\n            R = matmul(R,An,mod)\n        An = matmul(An,An,mod)\n     \
    \   K >>= 1\n    return R\n\nmod = 998244353\n\ndef rint(shift=0, base=10):\n\
    \    return [int(x, base) + shift for x in input().split()]\n\nN, Q = rint()\n\
    \ndef op(x,y):\n    return (x+y)%mod\n\ndef inv(x):\n    return (-x)%mod\n\npdsu\
    \ = PotentializedDSU(op,inv,0,N)\n\nfor _ in range(Q):\n    t, *q = rint()\n \
    \   if t:\n        u, v = q\n        ans = pdsu.diff(u, v) if pdsu.same(u, v)\
    \ else -1\n        print(ans)\n    else:\n        u, v, x = q\n        print(int(pdsu.consistent(u,v,x)))\n\
    \        pdsu.merge(u, v, x)\n\n"
  code: "# verification-helper: PROBLEM https://judge.yosupo.jp/problem/unionfind_with_potential\n\
    \nclass PotentializedDSU:\n\n    def __init__(self, op, inv, e, v) -> None:\n\
    \        n = v if isinstance(v, int) else len(v)\n        self.n = n\n       \
    \ self.par = [-1] * n\n        self.op = op\n        self.inv = inv\n        self.e\
    \ = e\n        self.pot = [e] * n if isinstance(v, int) else v\n\n    def leader(self,\
    \ x: int) -> int:\n        assert 0 <= x < self.n\n        path = []\n       \
    \ while self.par[x] >= 0:\n            path.append(x)\n            x = self.par[x]\n\
    \        for y in reversed(path):\n            self.pot[y] = self.op(self.pot[y],\
    \ self.pot[self.par[y]])\n            self.par[y] = x\n        return x\n    \n\
    \    def consistent(self, x: int, y: int, w) -> bool:\n        rx = self.leader(x)\n\
    \        ry = self.leader(y)\n        if rx == ry:\n            return self.op(self.pot[x],\
    \ self.inv(self.pot[y])) == w\n        return True\n\n    def merge(self, x: int,\
    \ y: int, w) -> int:\n        assert 0 <= x < self.n\n        assert 0 <= y <\
    \ self.n\n        rx = self.leader(x)\n        ry = self.leader(y)\n        if\
    \ rx == ry:\n            return rx\n        \n        if self.par[rx] < self.par[ry]:\n\
    \            x,y,w,rx,ry = y,x,self.inv(w),ry,rx\n            \n        self.par[ry]\
    \ += self.par[rx]\n        self.par[rx] = ry\n        self.pot[rx] = self.op(\n\
    \            self.op(self.inv(self.pot[x]), w), self.pot[y]\n        )\n     \
    \   return ry\n\n    def same(self, x: int, y: int) -> bool:\n        assert 0\
    \ <= x < self.n\n        assert 0 <= y < self.n\n        return self.leader(x)\
    \ == self.leader(y)\n    \n    def size(self, x: int) -> int:\n        assert\
    \ 0 <= x < self.n\n        return -self.par[self.leader(x)]\n    \n    def groups(self):\n\
    \        leader_buf = [self.leader(i) for i in range(self.n)]\n\n        result\
    \ = [[] for _ in range(self.n)]\n        for i in range(self.n):\n           \
    \ result[leader_buf[i]].append(i)\n\n        return list(filter(lambda r: r, result))\n\
    \n    def diff(self, x: int, y: int):\n        assert self.same(x, y)\n      \
    \  return self.op(self.pot[x], self.inv(self.pot[y]))\n\nimport math\n# from bisect\
    \ import bisect_left\nfrom bisect import bisect_right\n\ndef matmul(A, B, mod):\n\
    \    N1, N2, N3 = len(A),len(B),len(B[0])\n    R = [[0]*N3 for _ in range(N1)]\n\
    \    for i in range(N1):\n        for j in range(N3):\n            for k in range(N2):\n\
    \                R[i][j] += A[i][k]*B[k][j] % mod\n                R[i][j] %=\
    \ mod\n    return R\n\nfrom bisect import bisect_left\n\ndef matpow(A, K, mod):\n\
    \    N = len(A)\n    R = [[int(i == j) for j in range(N)] for i in range(N)]\n\
    \    An = [[aij for aij in ai] for ai in A]\n    while K > 0:\n        if K &\
    \ 1:\n            R = matmul(R,An,mod)\n        An = matmul(An,An,mod)\n     \
    \   K >>= 1\n    return R\n\nmod = 998244353\n\ndef rint(shift=0, base=10):\n\
    \    return [int(x, base) + shift for x in input().split()]\n\nN, Q = rint()\n\
    \ndef op(x,y):\n    return (x+y)%mod\n\ndef inv(x):\n    return (-x)%mod\n\npdsu\
    \ = PotentializedDSU(op,inv,0,N)\n\nfor _ in range(Q):\n    t, *q = rint()\n \
    \   if t:\n        u, v = q\n        ans = pdsu.diff(u, v) if pdsu.same(u, v)\
    \ else -1\n        print(ans)\n    else:\n        u, v, x = q\n        print(int(pdsu.consistent(u,v,x)))\n\
    \        pdsu.merge(u, v, x)\n\n"
  dependsOn: []
  isVerificationFile: false
  path: 1.py
  requiredBy: []
  timestamp: '2024-08-14 00:25:50+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: 1.py
layout: document
redirect_from:
- /library/1.py
- /library/1.py.html
title: 1.py
---
